{"file_contents":{"index.js":{"content":"const express = require('express');\nconst axios = require('axios');\n\nconst app = express();\nconst PORT = 5000;\n\napp.use(express.json());\n\nconst ROBLOX_SECURITY_TOKEN = process.env.ROBLOX_SECURITY_TOKEN || \"\";\n\nconst LEET_MAP = {\n  'a': ['4'],\n  'b': ['8', '13', 'l3', '6'],\n  'e': ['3'],\n  'f': ['ph'],\n  'g': ['6', '9'],\n  'i': ['1', 'l'], \n  'l': ['1', '7', 'l_'],\n  'o': ['0'],\n  'p': ['9'],\n  'q': ['9', '2'],\n  'r': ['12', 'lz'],\n  's': ['5', 'z', '2'],\n  't': ['7', '1', 'l'],\n  'w': ['vv', 'uu'],\n  'x': ['ex', 'ecks'],\n  'z': ['2']\n};\n\nconst SLANG_LIST = [\n  \"labubu\", \"popmart\", \"hirono\", \"crybaby\", \"dimoo\", \"skullpanda\", \"zimomo\", \"kpopdemonhunters\", \"demon_hunter\",\n  \"tungtungsahur\", \"sahur\", \"bukber\", \"takjil\", \"lebaran\", \"thr\", \"bjir\", \"wkwk\", \"anjay\", \"bocil\", \"epep\", \"cilukba\",\n  \"kats_eye\", \"bk_foot_lettuce\", \"number_15\",\n  \"sonny_angel\", \"smiski\", \"owala\", \"stanley_cup\", \"coquette\", \"bows\", \"downtown_girl\", \"star_boy\",\n  \"luh_calm_fit\", \"tuff\", \"motion\", \"standing_on_business\", \"crash_out\", \"crashing_out\", \"hawk_tuah\", \"spit_on_that_thang\",\n  \"winter_arc\", \"lock_in\", \"locked_in\", \"typeshit\", \"type_shit\", \"fein\", \"not_like_us\", \"euphoria\", \"meet_the_grahams\",\n  \"matcha_latte\", \"oat_milk\", \"cold_brew\", \"sriracha\", \"baja_blast\", \"grimace_shake\", \"pink_sauce\", \"prime_drink\",\n  \"lunchly\", \"feastables\", \"mrbeast_bar\", \"takis\", \"hot_cheetos\", \"buldak\", \"samyang\", \"carbonara\", \"tanghulu\",\n  \"nah_id_win\", \"stand_proud\", \"domain_expansion\", \"infinite_void\", \"malevolent_shrine\", \"hollow_purple\", \"mahoraga\", \n  \"sukuna\", \"gojo\", \"toji\", \"geto\", \"solo_leveling\", \"jin_woo\", \"arise\", \"shadow_monarch\", \"bocchi\", \"rock\", \n  \"za_warudo\", \"kono_dio_da\", \"yare_yare\", \"bankai\", \"rasengan\", \"chidori\", \"dattebayo\", \"gear_5\", \"nika\", \"joyboy\",\n  \"shibuya_incident\", \"culling_game\", \"black_flash\", \"blue_lock\", \"isagi\", \"egoist\", \"bachira\", \"nagi\", \"barou\",\n  \"demon_slayer\", \"tanjiro\", \"nezuko\", \"zenitsu\", \"inosuke\", \"rengoku\", \"muzans\", \"akaza\", \"kokushibo\", \"yoriichi\",\n  \"chainsaw_man\", \"denji\", \"makima\", \"power\", \"aki\", \"pochita\", \"gun_devil\", \"control_devil\", \"spy_x_family\", \"anya\",\n  \"yor_forger\", \"loid_forger\", \"bond\", \"berserk\", \"guts\", \"griffith\", \"behelit\", \"eclipse\", \"dragonslayer\", \"brand_of_sacrifice\",\n  \"one_piece\", \"luffy\", \"zoro\", \"sanji\", \"nami\", \"usopp\", \"chopper\", \"robin\", \"franky\", \"brook\", \"jinbe\", \"kaido\",\n  \"shanks\", \"mihawk\", \"buggy\", \"cross_guild\", \"marineford\", \"wano\", \"egghead\", \"gear_2\", \"gear_3\", \"gear_4\", \"haki\",\n  \"evangelion\", \"shinji\", \"asuka\", \"rei\", \"unit_01\", \"nerv\", \"seele\", \"impact\", \"angel\", \"spear_of_longinus\",\n  \"skibidi\", \"skibidi_toilet\", \"fanum\", \"fanum_tax\", \"gyatt\", \"gyat\", \"rizz\", \"rizzler\", \"sigma\", \"sigma_male\", \"ohio\", \"only_in_ohio\",\n  \"baby_gronk\", \"livvy_dunne\", \"mewing\", \"mog\", \"mogging\", \"looksmax\", \"looksmaxxing\", \"edging\", \"bussin\", \n  \"sheesh\", \"glaze\", \"glazing\", \"yapping\", \"yapper\", \"blud\", \"cuh\", \"jit\", \"shiesty\", \"opp\", \"opps\", \"zaza\", \"delulu\", \"solulu\",\n  \"sus\", \"amogus\", \"impostor\", \"baka\", \"sussy\", \"vented\", \"karen\", \"boomer\", \"zoomer\", \"ok_boomer\", \"no_cap\", \"fr\", \"ong\", \n  \"bet\", \"finna\", \"yeet\", \"yoink\", \"periodt\", \"slay\", \"ate\", \"left_no_crumbs\", \"main_character\", \"npc\", \"npc_energy\", \"bombastic\",\n  \"brain_rot\", \"doom_scrolling\", \"chronically_online\", \"ipad_kid\", \"sephora_kid\", \"stan_twitter\", \"plot_armor\", \"jump_scare\", \n  \"fever_dream\", \"backrooms\", \"liminal_space\", \"thug_shaker\", \"ambatukam\", \"omaygot\", \"dreamybull\", \"batman_arkham\", \"jonkler\", \n  \"man_ham\", \"killer_cock\", \"is_he_stupid\", \"lore_reason\", \"just_created\", \"character_name\", \"metal_pipe\", \"falling_pipe\",\n  \"vine_boom\", \"bruh_sound\", \"taco_bell_bong\", \"soda\", \"obamna\", \"biden_blast\", \"dark_brandon\", \"let_me_be_clear\",\n  \"chocolate_chocolate\", \"ice_cream\", \"bing_chilling\", \"lao_gan_ma\", \"john_xina\", \"social_credit\", \"wocky_slush\", \"oacky_way\",\n  \"skill_issue\", \"diff\", \"jungle_diff\", \"top_diff\", \"mid_diff\", \"bot_frag\", \"top_frag\", \"touch_grass\", \"ggez\", \"get_gud\", \n  \"ratio\", \"l_ratio\", \"w_mans\", \"common_w\", \"rare_l\", \"rage_quit\", \"speedrun\", \"hax\", \"haxxor\", \"pwned\", \"rekt\",\n  \"aimbot\", \"wallhack\", \"spinbot\", \"admin_abuse\", \"permaban\", \"shadowban\", \"alt_account\", \"smurf\", \"inting\", \"feeding\", \n  \"trolling\", \"griefing\", \"spawn_peek\", \"one_tap\", \"clip_it\", \"clipped\", \"caught_in_4k\", \"pocket_sage\", \"battle_pass\",\n  \"clutch\", \"ace\", \"penta_kill\", \"quadra_kill\", \"triple_kill\", \"double_kill\", \"first_blood\", \"killing_spree\", \"godlike\",\n  \"legendary\", \"shutdown\", \"executed\", \"wasted\", \"busted\", \"mission_passed\", \"respect_plus\", \"wasted_money\", \"heist\",\n  \"rank_up\", \"derank\", \"hardstuck\", \"elo_hell\", \"matchmaking\", \"rng\", \"rng_gods\", \"gacha\", \"pity\", \"fifty_fifty\",\n  \"whale\", \"dolphin\", \"f2p\", \"p2w\", \"grind\", \"farming\", \"afk\", \"brb\", \"gtg\", \"omw\", \"npc_interaction\", \"dialogue_skipper\",\n  \"speedrunner\", \"tas\", \"glitchless\", \"any_percent\", \"softlock\", \"hardlock\", \"crash\", \"blue_screen\", \"lag\", \"ping\",\n  \"packet_loss\", \"rubber_band\", \"server_issue\", \"devs_lazy\", \"indie_dev\", \"aaa_game\", \"bug\", \"feature\", \"patch_notes\",\n  \"nerf\", \"buff\", \"rework\", \"balance\", \"meta\", \"off_meta\", \"cheese\", \"strat\", \"tactics\", \"callouts\", \"comms\",\n  \"bloxy\", \"devex\", \"dominus\", \"valkyrie\", \"headless\", \"korblox\", \"limiteds\", \"adopt_me\", \"brookhaven\", \"bloxburg\", \"bedwars\", \n  \"da_hood\", \"arsenal\", \"phantom_forces\", \"pet_sim\", \"psx\", \"pet_sim_99\", \"titanic\", \"huge\", \"exclusive\", \"shiny\", \"rainbow\",\n  \"dark_matter\", \"golden\", \"diamond\", \"emerald\", \"obsidian\", \"void\", \"hacked\", \"beamed\", \"cookie_logged\", \"pged\", \"poisoned\",\n  \"clean\", \"rap\", \"value\", \"demand\", \"projection\", \"flipping\", \"snipping\", \"botting\", \"trade_hangout\", \"mm2\", \"murder_mystery\",\n  \"sheriff\", \"murderer\", \"innocent\", \"godly\", \"chroma\", \"ancient\", \"vintage\", \"corrupt\", \"luger\", \"shark\", \"slasher\", \"heat\",\n  \"laser\", \"fang\", \"saw\", \"seer\", \"gem\", \"coin\", \"prestige\", \"rebirth\", \"leaderboard\", \"obby\", \"tower_of_hell\", \"toh\",\n  \"misery\", \"jukes_towers\", \"citadel\", \"steeple\", \"difficulty_chart\", \"parkour\", \"shift_lock\", \"flick\", \"wall_hop\", \"ladder_flick\",\n  \"corner_clip\", \"laugh_clip\", \"dance_clip\", \"glitch_wrap\", \"stud\", \"truss\", \"conveyor\", \"killbrick\", \"checkpoint\", \"stage\",\n  \"tycoon\", \"dropper\", \"upgrader\", \"conveyor_belt\", \"cash_grab\", \"simulator\", \"clicking\", \"tapping\", \"mining\", \"lifting\",\n  \"boxing\", \"fighting\", \"anime_defenders\", \"toilet_tower\", \"ttd\", \"all_star\", \"astd\", \"bloxfruits\", \"kitsune\", \"leopard\",\n  \"dragon\", \"spirit\", \"control\", \"venom\", \"shadow\", \"dough\", \"t_rex\", \"mammoth\", \"gravity\", \"blizzard\", \"pain\", \"rumble\",\n  \"portal\", \"phoenix\", \"sound\", \"spider\", \"love\", \"buddha\", \"quake\", \"magma\", \"ghost\", \"barrier\", \"rubber\", \"light\",\n  \"diamond_fruit\", \"dark_fruit\", \"sand\", \"ice\", \"falcon\", \"flame\", \"spike\", \"smoke\", \"bomb\", \"spring\", \"chop\", \"spin\",\n  \"rocket\", \"perm\", \"permanent\", \"gamepass\", \"fruit_notif\", \"dark_blade\", \"yig\", \"cdk\", \"cursed_dual\", \"soul_guitar\",\n  \"ghoul\", \"cyborg\", \"mink\", \"human\", \"shark_race\", \"angel_race\", \"v4\", \"awakening\", \"raid\", \"fragment\", \"beli\",\n  \"jett\", \"reyna\", \"sage\", \"omen\", \"phoenix\", \"raze\", \"sova\", \"cypher\", \"brimstone\", \"viper\", \"killjoy\", \"skye\", \"yoru\",\n  \"astra\", \"kayo\", \"chamber\", \"neon\", \"fade\", \"harbor\", \"gekko\", \"deadlock\", \"iso\", \"clove\", \"radiant\", \"immortal\",\n  \"ascendant\", \"diamond\", \"platinum\", \"gold\", \"silver\", \"bronze\", \"iron\", \"tenz\", \"faker\", \"shroud\", \"tarik\", \"aceu\",\n  \"cottagecore\", \"goblincore\", \"fairycore\", \"weirdcore\", \"dreamcore\", \"traumacore\", \"glitchcore\", \"webcore\", \"oldweb\",\n  \"frutiger_aero\", \"y2k\", \"cyberpunk\", \"steampunk\", \"dieselpunk\", \"solarpunk\", \"vaporwave\", \"synthwave\", \"retrowave\",\n  \"dark_academia\", \"light_academia\", \"balletcore\", \"barbiecore\", \"bimbocore\", \"normcore\", \"gorpcore\", \"blokecore\",\n  \"doggo\", \"pupper\", \"woofer\", \"floof\", \"good_boy\", \"zoomies\", \"sploot\", \"blep\", \"mlem\", \"beans\", \"toe_beans\",\n  \"catto\", \"kitten\", \"void_cat\", \"orange_cat\", \"one_brain_cell\", \"loaf\", \"liquid_cat\", \"if_i_fits\", \"i_sits\",\n  \"capybara\", \"ok_i_pull_up\", \"coconut_doggy\", \"frogge\", \"phrog\", \"wednesday\", \"my_dudes\", \"axolotl\", \"minecraft_axolotl\",\n  \"uwu\", \"owo\", \"uwu_girl\", \"gamer_girl\", \"egirl\", \"eboy\", \"pick_me_boy\", \"soft_boy\", \"golden_retriever\", \"black_cat\"\n];\n\nconst BASE_BAD_WORDS = [\n  \"2g1c\", \"acrotomophilia\", \"anal\", \"anilingus\", \"anus\", \"apeshit\", \"arsehole\", \"ass\", \"asshole\", \"assmunch\",\n  \"babeland\", \"ballgag\", \"ballsack\", \"bastard\", \"bdsm\", \"beaner\", \"bestiality\", \"bitch\", \"blowjob\", \"blumpkin\",\n  \"bollocks\", \"bondage\", \"boner\", \"boob\", \"boobs\", \"bukkake\", \"bulldyke\", \"bullshit\", \"bunghole\", \"butt\",\n  \"butthole\", \"cameltoe\", \"camgirl\", \"camslut\", \"circlejerk\", \"clit\", \"clitoris\", \"clusterfuck\", \"cock\", \"cocks\",\n  \"coon\", \"coons\", \"crap\", \"crappy\", \"creampie\", \"cum\", \"cumming\", \"cunnilingus\", \"cunt\", \"darkie\", \"daterape\",\n  \"deepthroat\", \"dick\", \"dildo\", \"doggiestyle\", \"doggystyle\", \"domination\", \"dominatrix\", \"donkeypunch\", \"dp\",\n  \"dryhump\", \"dvda\", \"ejaculation\", \"erotic\", \"escort\", \"faggot\", \"fecal\", \"felch\", \"fellatio\", \"femdom\",\n  \"fingerbang\", \"fingering\", \"fisting\", \"footjob\", \"frotting\", \"fuck\", \"fuckin\", \"fucking\", \"fucktards\",\n  \"fudgepacker\", \"futanari\", \"gangbang\", \"gaysex\", \"genitals\", \"goatse\", \"goddamn\", \"grope\", \"handjob\",\n  \"hardcore\", \"hentai\", \"hooker\", \"horny\", \"humping\", \"incest\", \"intercourse\", \"jailbait\", \"jerkoff\", \"jigaboo\",\n  \"jiggaboo\", \"kike\", \"kinky\", \"kkk\", \"klan\", \"lapdance\", \"lesbian\", \"lolita\", \"masturbate\", \"masturbating\",\n  \"masturbation\", \"milf\", \"molestation\", \"molest\", \"motherfucker\", \"muff\", \"negro\", \"neonazi\", \"nigga\",\n  \"nigger\", \"nipple\", \"nipples\", \"nsfwporn\", \"nude\", \"nudity\", \"nympho\", \"orgasm\", \"orgy\", \"paedophile\",\n  \"panties\", \"pedophile\", \"pedobear\", \"pegging\", \"penis\", \"pimp\", \"piss\", \"pissing\", \"playboy\", \"poop\",\n  \"pooping\", \"porn\", \"porno\", \"pornography\", \"prostitute\", \"pthc\", \"pube\", \"pubes\", \"pubic\", \"pussy\",\n  \"queef\", \"rape\", \"raping\", \"rapist\", \"rectum\", \"retard\", \"rimjob\", \"rimming\", \"sadism\", \"scat\", \"schlong\",\n  \"scissoring\", \"semen\", \"sex\", \"sexo\", \"sexy\", \"shemale\", \"shit\", \"shitty\", \"shota\", \"slut\", \"slutty\",\n  \"smegma\", \"sodomy\", \"spic\", \"spunk\", \"strapon\", \"strappado\", \"stripper\", \"suck\", \"swastika\", \"taint\",\n  \"testicle\", \"threesome\", \"throating\", \"tit\", \"tits\", \"titties\", \"titty\", \"topless\", \"tranny\", \"tribbing\",\n  \"turd\", \"twat\", \"undressing\", \"upskirt\", \"urethra\", \"vagina\", \"viagra\", \"vibrator\", \"voyeur\", \"vulva\",\n  \"wank\", \"wanking\", \"wetback\", \"whore\", \"whorehouse\", \"xxx\"\n];\n\nconst dictCache = new Map();\n\nasync function checkIsProfane(text) {\n  try {\n    const encodedText = encodeURIComponent(text);\n    const url = `https://www.purgomalum.com/service/json?text=${encodedText}`;\n    const response = await axios.get(url);\n    if (response.data.result && response.data.result.indexOf(\"*\") !== -1) return true;\n    return false;\n  } catch (e) {\n    return false;\n  }\n}\n\nasync function getRandomWord(mode) {\n  try {\n    const response = await axios.get(\"https://random-word-api.herokuapp.com/word?number=5\");\n    const words = response.data;\n    if (mode === \"short\") {\n      const short = words.find(w => w.length <= 5);\n      return short || words[0];\n    } else if (mode === \"medium\") {\n      const med = words.find(w => w.length <= 9);\n      return med || words[0];\n    }\n    return words[0];\n  } catch (e) {\n    return \"bruh\";\n  }\n}\n\nasync function isDictionaryWord(word) {\n  if (dictCache.has(word)) {\n    return dictCache.get(word);\n  }\n  try {\n    const url = `https://api.dictionaryapi.dev/api/v2/entries/en/${word}`;\n    const response = await axios.get(url, { validateStatus: () => true });\n    const isValid = response.status === 200;\n    dictCache.set(word, isValid);\n    return isValid;\n  } catch (e) {\n    console.log(\"Dictionary API Error: \" + e);\n    return false;\n  }\n}\n\nfunction deLeetStringWithMap(str) {\n  if (!str) return \"\";\n  let processed = str.toLowerCase();\n  const replacements = [];\n  for (const realChar in LEET_MAP) {\n    const symbols = LEET_MAP[realChar];\n    for (let i = 0; i < symbols.length; i++) {\n      replacements.push({ leet: symbols[i], real: realChar });\n    }\n  }\n  replacements.sort((a, b) => b.leet.length - a.leet.length);\n  for (let j = 0; j < replacements.length; j++) {\n    const item = replacements[j];\n    const esc = item.leet.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    const re = new RegExp(esc, \"g\");\n    processed = processed.replace(re, item.real);\n  }\n  return processed;\n}\n\nfunction generateRepeatedVariations(text) {\n  if (!text) return [];\n  const groups = [];\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    if (groups.length > 0 && groups[groups.length - 1][0] === char) {\n      groups[groups.length - 1] += char;\n    } else {\n      groups.push(char);\n    }\n  }\n  const optionsList = [];\n  for (let g = 0; g < groups.length; g++) {\n    const group = groups[g];\n    const char = group[0];\n    if (group.length === 1) {\n      optionsList.push([char]);\n    } else {\n      optionsList.push([char, char + char]);\n    }\n  }\n  return cartesianProduct(optionsList);\n}\n\nfunction cartesianProduct(arrays) {\n  let result = [\"\"];\n  if (arrays.length > 15) return [arrays.map(a => a[0]).join(\"\")];\n  for (let i = 0; i < arrays.length; i++) {\n    const currentOptions = arrays[i];\n    const temp = [];\n    if (result.length > 200) return result;\n    for (let r = 0; r < result.length; r++) {\n      for (let o = 0; o < currentOptions.length; o++) {\n        temp.push(result[r] + currentOptions[o]);\n      }\n    }\n    result = temp;\n  }\n  return result;\n}\n\nfunction shuffleArray(array) {\n  const arr = [...array];\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n  return arr;\n}\n\nasync function stripSafeDictionaryWords(str) {\n  const chars = str.split(\"\");\n  const length = chars.length;\n  for (let i = 0; i < length; i++) {\n    for (let len = 12; len >= 3; len--) {\n      if (i + len > length) continue;\n      const substring = str.substring(i, i + len);\n      if (substring.indexOf(\" \") !== -1) continue;\n      if (await isDictionaryWord(substring)) {\n        if (BASE_BAD_WORDS.indexOf(substring) !== -1) {\n          continue;\n        }\n        for (let k = 0; k < len; k++) {\n          chars[i + k] = \" \";\n        }\n        i += len - 1;\n        break;\n      }\n    }\n  }\n  return chars.join(\"\");\n}\n\nasync function isProfaneDeepScan(text) {\n  if (!text) return false;\n  const lowerText = text.toLowerCase();\n  const rootsToCheck = [lowerText.replace(/[\\s_\\-\\.]/g, \"\")];\n  if (/[\\s_\\-\\.]/.test(lowerText)) {\n    const vowels = ['a', 'e', 'i', 'o', 'u'];\n    for (let v = 0; v < vowels.length; v++) {\n      rootsToCheck.push(lowerText.replace(/[\\s_\\-\\.]/g, vowels[v]));\n    }\n  }\n  const cleanBase = rootsToCheck[0];\n  const deLeeted = deLeetStringWithMap(cleanBase);\n  if (deLeeted !== cleanBase) {\n    rootsToCheck.push(deLeeted);\n  }\n  let allCandidates = [];\n  for (let i = 0; i < rootsToCheck.length; i++) {\n    const root = rootsToCheck[i];\n    if (i === 0) {\n      allCandidates = allCandidates.concat(generateRepeatedVariations(root));\n    } else {\n      allCandidates.push(root);\n    }\n  }\n  allCandidates = [...new Set(allCandidates)];\n  console.log(\"Deep Scan checking \" + allCandidates.length + \" candidates\");\n  for (let c = 0; c < allCandidates.length; c++) {\n    const variant = allCandidates[c];\n    if (BASE_BAD_WORDS.indexOf(variant) !== -1) {\n      console.log(\"FAIL: Found '\" + variant + \"' in ban list.\");\n      return true;\n    }\n    const eaten = await stripSafeDictionaryWords(variant);\n    if (eaten.trim().length === 0) continue;\n    for (let b = 0; b < BASE_BAD_WORDS.length; b++) {\n      if (eaten.indexOf(BASE_BAD_WORDS[b]) !== -1) {\n        console.log(\"FAIL: Detected '\" + BASE_BAD_WORDS[b] + \"' inside '\" + variant + \"'\");\n        return true;\n      }\n    }\n    const variantSkeleton = variant.replace(/[aeiou]/g, \"\");\n    if (variantSkeleton.length >= 2) {\n      for (let k = 0; k < BASE_BAD_WORDS.length; k++) {\n        const rootBad = BASE_BAD_WORDS[k];\n        const badSkeleton = rootBad.replace(/[aeiou]/g, \"\");\n        if (badSkeleton.length >= 2 && variantSkeleton === badSkeleton) {\n          console.log(\"FAIL: Skeleton match (\" + variantSkeleton + \")\");\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nasync function isComposedOfSafeWords(username) {\n  const roots = [username];\n  const deLeeted = deLeetStringWithMap(username);\n  if (deLeeted !== username) {\n    roots.push(deLeeted);\n  }\n  for (let i = 0; i < roots.length; i++) {\n    const root = roots[i];\n    if (!/^[a-zA-Z]+$/.test(root)) {\n      continue;\n    }\n    let badWordFound = \"\";\n    async function decompose(remainingString) {\n      if (remainingString.length === 0) {\n        return true;\n      }\n      for (let len = remainingString.length; len >= 3; len--) {\n        const currentWord = remainingString.substring(0, len);\n        if (await isDictionaryWord(currentWord)) {\n          if (BASE_BAD_WORDS.indexOf(currentWord) !== -1) {\n            badWordFound = currentWord;\n            return true;\n          }\n          const restOfString = remainingString.substring(len);\n          if (await decompose(restOfString)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n    const isFullyDecomposed = await decompose(root);\n    if (isFullyDecomposed) {\n      return {\n        isSafe: true,\n        hasBadWord: (badWordFound.length > 0),\n        badWord: badWordFound\n      };\n    }\n  }\n  return {\n    isSafe: false,\n    hasBadWord: false,\n    badWord: \"\"\n  };\n}\n\nasync function checkUsernameAvailability(usernameToTest) {\n  console.log(\"--- Checking Availability for: \" + usernameToTest + \" ---\");\n  if (!/^[a-zA-Z0-9_]+$/.test(usernameToTest)) {\n    console.log(\"FAIL: Regex validation failed (Invalid characters).\");\n    return false;\n  }\n  const underscores = (usernameToTest.match(/_/g) || []).length;\n  if (underscores > 1) {\n    console.log(\"FAIL: Too many underscores.\");\n    return false;\n  }\n  if (usernameToTest.length < 3 || usernameToTest.length > 20) {\n    console.log(\"FAIL: Length must be 3-20 characters.\");\n    return false;\n  }\n  let shouldRunDeepScan = true;\n  const lowerUser = usernameToTest.toLowerCase();\n  const safetyCheckResult = await isComposedOfSafeWords(lowerUser);\n  if (safetyCheckResult.isSafe) {\n    if (safetyCheckResult.hasBadWord) {\n      console.log(\"FAIL: Composed of real words, but component '\" + safetyCheckResult.badWord + \"' is on the ban list.\");\n      return false;\n    } else {\n      console.log(\"SKIP: Username is composed entirely of safe dictionary words. Skipping deep scan.\");\n      shouldRunDeepScan = false;\n    }\n  }\n  if (shouldRunDeepScan) {\n    if (await isProfaneDeepScan(usernameToTest)) {\n      console.log(\"FAIL: Profanity detected in deep scan.\");\n      return false;\n    }\n  }\n  const apiUrl = \"https://users.roblox.com/v1/usernames/users\";\n  const payload = { \"usernames\": [usernameToTest], \"excludeBannedUsers\": false };\n  try {\n    console.log(\"Querying Roblox API (check if taken)...\");\n    const response = await axios.post(apiUrl, payload, {\n      headers: {\n        'Content-Type': 'application/json',\n        'Cookie': ROBLOX_SECURITY_TOKEN\n      },\n      validateStatus: () => true\n    });\n    if (response.status !== 200) {\n      console.error(\"ROBLOX API ERROR: \" + response.status);\n      return false;\n    }\n    const jsonResponse = response.data;\n    const isRobloxAvailable = (jsonResponse.data && jsonResponse.data.length === 0);\n    if (!isRobloxAvailable) {\n      console.log(\"FAIL: Username taken on Roblox.\");\n      return false;\n    }\n    console.log(\"Roblox says available. Checking Purgomalum...\");\n    const isClean = !(await checkIsProfane(usernameToTest));\n    if (!isClean) console.log(\"FAIL: Purgomalum flagged it.\");\n    else console.log(\"SUCCESS: Username is available!\");\n    return isClean;\n  } catch (error) {\n    console.error(\"CRITICAL EXCEPTION in Roblox API fetch: \" + error);\n    return false;\n  }\n}\n\nasync function solveLeetspeak(word) {\n  const wordArr = word.toLowerCase().split('');\n  const indices = [];\n  for (let i = 0; i < wordArr.length; i++) {\n    if (LEET_MAP[wordArr[i]]) indices.push(i);\n  }\n  if (indices.length === 0) return null;\n  const maxLevel = Math.min(indices.length, 5);\n  for (let level = 1; level <= maxLevel; level++) {\n    for (let attempt = 0; attempt < 5; attempt++) {\n      const tempWordArr = [...wordArr];\n      const targets = shuffleArray(indices).slice(0, level);\n      targets.forEach(idx => {\n        const char = tempWordArr[idx];\n        const replacements = LEET_MAP[char];\n        const replacementIdx = Math.floor(Math.random() * Math.min(replacements.length, 2));\n        tempWordArr[idx] = replacements[replacementIdx];\n      });\n      const candidate = tempWordArr.join('');\n      if (candidate.length >= 3 && candidate.length <= 20) {\n        if (await checkUsernameAvailability(candidate)) {\n          return candidate;\n        }\n      }\n    }\n  }\n  return null;\n}\n\nasync function generateCoolUsername() {\n  const isComboMode = Math.random() < 0.30;\n  const slangListDefined = SLANG_LIST && SLANG_LIST.length > 0;\n  if (isComboMode) {\n    const comboType = Math.random();\n    let part1 = \"\";\n    let part2 = \"\";\n    if (comboType < 0.33) {\n      const allowLong = Math.random() < 0.20;\n      part1 = await getRandomWord(allowLong ? \"medium\" : \"short\");\n      part2 = await getRandomWord(allowLong ? \"medium\" : \"short\");\n    } else if (comboType < 0.66) {\n      const rawSlang = slangListDefined ? SLANG_LIST[Math.floor(Math.random() * SLANG_LIST.length)] : await getRandomWord(\"short\");\n      part1 = rawSlang.replace(/_/g, \"\");\n      part2 = await getRandomWord(\"short\");\n    } else {\n      part1 = await getRandomWord(\"short\");\n      const rawSlang = slangListDefined ? SLANG_LIST[Math.floor(Math.random() * SLANG_LIST.length)] : await getRandomWord(\"short\");\n      part2 = rawSlang.replace(/_/g, \"\");\n    }\n    part1 = part1.charAt(0).toUpperCase() + part1.slice(1);\n    part2 = part2.charAt(0).toUpperCase() + part2.slice(1);\n    let combined = part1 + part2;\n    if (combined.length > 20) combined = combined.substring(0, 20);\n    if (await checkUsernameAvailability(combined)) {\n      return { \"username\": combined, \"available\": true, \"method\": \"ComboMode\" };\n    } else {\n      return { \"available\": false };\n    }\n  } else {\n    let baseWord = \"\";\n    const isSlang = Math.random() < 0.85;\n    if (isSlang && slangListDefined) {\n      const rawSlang = SLANG_LIST[Math.floor(Math.random() * SLANG_LIST.length)];\n      baseWord = rawSlang.replace(/_/g, \"\");\n    } else {\n      baseWord = await getRandomWord(\"random\");\n    }\n    if (await checkUsernameAvailability(baseWord)) {\n      return { \"username\": baseWord, \"available\": true, \"method\": \"CleanRandom\" };\n    }\n    const leetResult = await solveLeetspeak(baseWord);\n    if (leetResult) {\n      return { \"username\": leetResult, \"available\": true, \"method\": \"Leetspeak\" };\n    }\n    return { \"available\": false };\n  }\n}\n\nasync function handleCoolRequest() {\n  for (let i = 0; i < 4; i++) {\n    const result = await generateCoolUsername();\n    if (result.available && !(await isProfaneDeepScan(result.username))) {\n      return result;\n    }\n  }\n  return {\n    \"username\": null,\n    \"available\": false,\n    \"error\": \"Generation timed out.\"\n  };\n}\n\nasync function handleRandomWordRequest() {\n  const w = await getRandomWord(\"random\");\n  const avail = await checkUsernameAvailability(w);\n  return { \"username\": w, \"available\": avail };\n}\n\nasync function handleSpecificCheck(username) {\n  if (!username) return \"TAKEN\";\n  return (await checkUsernameAvailability(username)) ? \"AVAILABLE\" : \"TAKEN\";\n}\n\napp.get('/', async (req, res) => {\n  res.json({ status: 'ok', message: 'Roblox Username Checker API' });\n});\n\napp.get('/api', async (req, res) => {\n  try {\n    if (req.query.cool === \"true\") {\n      const result = await handleCoolRequest();\n      return res.json(result);\n    }\n    if (req.query.word === \"true\") {\n      const result = await handleRandomWordRequest();\n      return res.json(result);\n    }\n    const result = await handleSpecificCheck(req.query.username);\n    return res.type('text').send(result);\n  } catch (error) {\n    console.error(\"Error:\", error);\n    res.status(500).json({ error: \"Internal server error\" });\n  }\n});\n\napp.listen(PORT, '0.0.0.0', () => {\n  console.log(`Server running on http://0.0.0.0:${PORT}`);\n});\n","path":null,"size_bytes":24382,"size_tokens":null},"replit.md":{"content":"# Roblox Username Checker API\n\n## Overview\nA Node.js Express server that checks Roblox username availability with profanity filtering and cool username generation.\n\n## Project Structure\n- `index.js` - Express server with API endpoints\n- `package.json` - Project configuration with dependencies\n\n## Dependencies\n- **express** - Web server framework\n- **axios** - HTTP client for API requests\n- **googleapis** - Google APIs client library\n\n## API Endpoints\n\n### GET /\nHealth check endpoint. Returns server status.\n\n### GET /api\nMain API endpoint with query parameters:\n- `?cool=true` - Generate a cool, available username\n- `?word=true` - Check a random word for availability\n- `?username=xyz` - Check if a specific username is available (returns \"AVAILABLE\" or \"TAKEN\")\n\n## Environment Variables\n- `ROBLOX_SECURITY_TOKEN` - (Optional) Roblox security token for authenticated API calls\n\n## Usage\nThe server runs on port 5000. Access the API at:\n```\nhttp://localhost:5000/api?username=testname\nhttp://localhost:5000/api?cool=true\nhttp://localhost:5000/api?word=true\n```\n\n## Recent Changes\n- December 10, 2025: Converted from Google Apps Script to Node.js Express server\n- Added express and axios dependencies\n- Replaced UrlFetchApp with axios for HTTP requests\n- Replaced ContentService with Express response methods\n- Server now listens on port 5000\n","path":null,"size_bytes":1348,"size_tokens":null}},"version":2}